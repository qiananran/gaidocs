import{_ as n,o as e,c as l,x as s,a as p,t,U as r}from"./chunks/framework.7f50b160.js";const g=JSON.parse('{"title":"通信机制简介","description":"","frontmatter":{"title":"通信机制简介"},"headers":[],"relativePath":"ros/base/index.md","lastUpdated":null}'),o={name:"ros/base/index.md"},c={id:"frontmatter-title",tabindex:"-1"},i=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=r(`<p>在ROS2中通信方式虽然有多种，但是不同通信方式的组成要素都是类似的，比如：通信是双方或多方行为、通信时都需要将不同的通信对象关联、都有各自的模型、交互数据时也必然涉及到数据载体等等。本节将会介绍通信中涉及到的一些术语。</p><h2 id="_1-节点" tabindex="-1">1.节点 <a class="header-anchor" href="#_1-节点" aria-label="Permalink to &quot;1.节点&quot;">​</a></h2><p>在通信时，不论采用何种方式，通信对象的构建都依赖于节点(Node)，在ROS2中，一般情况下每个节点都对应某一单一的功能模块(例如：雷达驱动节点可能负责发布雷达消息，摄像头驱动节点可能负责发布图像消息)。一个完整的机器人系统可能由许多协同工作的节点组成，ROS2中的单个可执行文件(C++程序或Python程序)可以包含一个或多个节点。</p><h2 id="_2-话题" tabindex="-1">2.话题 <a class="header-anchor" href="#_2-话题" aria-label="Permalink to &quot;2.话题&quot;">​</a></h2><p>话题(Topic)是一个纽带，具有相同话题的节点可以关联在一起，而这正是通信的前提。并且ROS2是跨语言的，有的节点可能是使用C++实现，有的节点可能是使用Python实现的，但是只要二者使用了相同的话题，就可以实现数据的交互。</p><h2 id="_3-通信模型" tabindex="-1">3.通信模型 <a class="header-anchor" href="#_3-通信模型" aria-label="Permalink to &quot;3.通信模型&quot;">​</a></h2><p>不同的通信对象通过话题关联到一起之后，以何种方式实现通信呢？在ROS2中，常用的通信模型有四种：</p><table><thead><tr><th><strong>通信种类</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>话题通信</strong></td><td>是一种单向通信模型，在通信双方中，发布方发布数据，订阅方订阅数据，数据流单向的由发布方传输到订阅方。</td></tr><tr><td><strong>服务通信</strong></td><td>是一种基于请求响应的通信模型，在通信双方中，客户端发送请求数据到服务端，服务端响应结果给客户端。</td></tr><tr><td><strong>动作通信</strong></td><td>是一种带有连续反馈的通信模型，在通信双方中，客户端发送请求数据到服务端，服务端响应结果给客户端，但是在服务端接收到请求到产生最终响应的过程中，会发送连续的反馈信息到客户端。</td></tr><tr><td><strong>参数服务</strong></td><td>是一种基于共享的通信模型，在通信双方中，服务端可以设置数据，而客户端可以连接服务端并操作服务端数据。</td></tr></tbody></table><h2 id="_4-接口" tabindex="-1">4.接口 <a class="header-anchor" href="#_4-接口" aria-label="Permalink to &quot;4.接口&quot;">​</a></h2><p>在通信过程中，需要传输数据，就必然涉及到数据载体，也即要以特定格式传输数据。在ROS2中，数据载体称之为接口(interfaces)。通信时使用的数据载体一般需要使用接口文件定义。常用的接口文件有三种：msg文件、srv文件与action文件。每种文件都可以按照一定格式定义特定数据类型的“变量”。</p><h3 id="_1-msg文件" tabindex="-1">1.msg文件 <a class="header-anchor" href="#_1-msg文件" aria-label="Permalink to &quot;1.msg文件&quot;">​</a></h3><p>msg文件是用于定义话题通信中数据载体的接口文件，一个典型的.msg文件示例如下。</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">numi1</span></span>
<span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">num2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在文件中声明了一些被传输的类似于C++变量的数据。</p><h3 id="_2-srv文件" tabindex="-1">2.srv文件 <a class="header-anchor" href="#_2-srv文件" aria-label="Permalink to &quot;2.srv文件&quot;">​</a></h3><p>srv文件是用于定义服务通信中数据载体的接口文件，一个典型的.srv文件示例如下。</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">num1</span></span>
<span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">num2</span></span>
<span class="line"><span style="color:#B392F0;">---</span></span>
<span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">sum</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>文件中声明的数据被---分割为两部分，上半部分用于声明请求数据，下半部分用于声明响应数据。</p><h3 id="_3-action文件" tabindex="-1">3.action文件 <a class="header-anchor" href="#_3-action文件" aria-label="Permalink to &quot;3.action文件&quot;">​</a></h3><p>action文件使用用于定义动作通信中数据载体的接口文件，一个典型的.action文件示例如下。</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">num</span></span>
<span class="line"><span style="color:#B392F0;">---</span></span>
<span class="line"><span style="color:#B392F0;">int64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">sum</span></span>
<span class="line"><span style="color:#B392F0;">---</span></span>
<span class="line"><span style="color:#B392F0;">float64</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">progress</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>文件中声明的数据被---分割为三部分，上半部分用于声明请求数据，中间部分用于声明响应数据，下半部分用于声明连续反馈数据。</p><p>4.变量类型</p><p>不管是何种接口文件，在文件中每行声明的数据都由字段类型和字段名称组成，可以使用的字段类型有：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">int8,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">int16,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">int32,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">int64</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">或者无符号类型:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">uint</span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">float32,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">float64</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">string</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">time, duration</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">其他msg文件</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">变长数组和定长数组</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>ROS中还有一种特殊类型：Header，标头包含时间戳和ROS2中常用的坐标帧信息。许多接口文件的第一行包含Header标头。</p><p>另外，需要说明的是：</p><blockquote><p>参数通信的数据无需定义接口文件，参数通信时数据会被封装为参数对象，参数客户端和服务端操作的都是参数对象。</p></blockquote><h2 id="准备工作" tabindex="-1">准备工作 <a class="header-anchor" href="#准备工作" aria-label="Permalink to &quot;准备工作&quot;">​</a></h2><p>1.请先创建工作空间ws01_plumbing，本章以及第3章代码部分内容存储在该工作空间下。</p><p>2.实际应用中一般建议创建专门的接口功能包定义接口文件，当前教程也遵循这一建议，预先创建教程所需使用的接口功能包(需要注意的是，目前为止无法在Python功能包中定义接口文件)，终端下进入工作空间的src目录，执行如下命令：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">ros2</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pkg</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--build-type</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">ament_cmake</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">base_interfaces_demo</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,32);function b(a,u,h,E,m,y){return e(),l("div",null,[s("h1",c,[p(t(a.$frontmatter.title)+" ",1),i]),d])}const _=n(o,[["render",b]]);export{g as __pageData,_ as default};
